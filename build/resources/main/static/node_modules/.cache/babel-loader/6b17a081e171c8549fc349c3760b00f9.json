{"ast":null,"code":"function createImperativePromise(promiseArg) {\n  var resolve = null;\n  var reject = null;\n  var wrappedPromise = new Promise(function (_resolve, _reject) {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  promiseArg && promiseArg.then(function (val) {\n    resolve && resolve(val);\n  }, function (error) {\n    reject && reject(error);\n  });\n  return {\n    promise: wrappedPromise,\n    resolve: function (value) {\n      resolve && resolve(value);\n    },\n    reject: function (reason) {\n      reject && reject(reason);\n    },\n    cancel: function () {\n      resolve = null;\n      reject = null;\n    }\n  };\n}\n\nexport { createImperativePromise };","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"iCAW2C,U,EAA0C;AACnF,MAAI,OAAO,GAA8B,IAAzC;AACA,MAAI,MAAM,GAA0B,IAApC;AAEA,MAAM,cAAc,GAAG,IAAI,OAAJ,CAAe,UAAC,QAAD,EAAW,OAAX,EAAkB;AACtD,IAAA,OAAO,GAAG,QAAV;AACA,IAAA,MAAM,GAAG,OAAT;AACD,GAHsB,CAAvB;AAKA,EAAA,UAAU,IAAI,UAAU,CAAC,IAAX,CACZ,UAAA,GAAA,EAAG;AACD,IAAA,OAAO,IAAI,OAAO,CAAC,GAAD,CAAlB;AACD,GAHW,EAIZ,UAAA,KAAA,EAAK;AACH,IAAA,MAAM,IAAI,MAAM,CAAC,KAAD,CAAhB;AACD,GANW,CAAd;AASA,SAAO;AACL,IAAA,OAAO,EAAE,cADJ;AAEL,IAAA,OAAO,EAAE,UAAC,KAAD,EAA0B;AACjC,MAAA,OAAO,IAAI,OAAO,CAAC,KAAD,CAAlB;AACD,KAJI;AAKL,IAAA,MAAM,EAAE,UAAC,MAAD,EAAa;AACnB,MAAA,MAAM,IAAI,MAAM,CAAC,MAAD,CAAhB;AACD,KAPI;AAQL,IAAA,MAAM,EAAE,YAAA;AACN,MAAA,OAAO,GAAG,IAAV;AACA,MAAA,MAAM,GAAG,IAAT;AACD;AAXI,GAAP;AAaD","sourcesContent":["export type ResolveCallback<T> = (value: T | PromiseLike<T>) => void\nexport type RejectCallback = (reason?: any) => void\nexport type CancelCallback = () => void\n\nexport type ImperativePromise<T> = {\n  promise: Promise<T>\n  resolve: ResolveCallback<T>\n  reject: RejectCallback\n  cancel: CancelCallback\n}\n\nexport function createImperativePromise<T>(promiseArg?: Promise<T> | null | undefined): ImperativePromise<T> {\n  let resolve: ResolveCallback<T> | null = null\n  let reject: RejectCallback | null = null\n\n  const wrappedPromise = new Promise<T>((_resolve, _reject) => {\n    resolve = _resolve\n    reject = _reject\n  })\n\n  promiseArg && promiseArg.then(\n    val => {\n      resolve && resolve(val)\n    },\n    error => {\n      reject && reject(error)\n    }\n  )\n\n  return {\n    promise: wrappedPromise,\n    resolve: (value: T | PromiseLike<T>) => {\n      resolve && resolve(value)\n    },\n    reject: (reason?: any) => {\n      reject && reject(reason)\n    },\n    cancel: () => {\n      resolve = null\n      reject = null\n    }\n  }\n}\n\n\n"]},"metadata":{},"sourceType":"module"}