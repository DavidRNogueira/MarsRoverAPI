{"ast":null,"code":"function createImperativePromise(promiseArg) {\n  var _resolve2 = null;\n  var _reject2 = null;\n  var wrappedPromise = new Promise(function (_resolve, _reject) {\n    _resolve2 = _resolve;\n    _reject2 = _reject;\n  });\n  promiseArg && promiseArg.then(function (val) {\n    _resolve2 && _resolve2(val);\n  }, function (error) {\n    _reject2 && _reject2(error);\n  });\n  return {\n    promise: wrappedPromise,\n    resolve: function resolve(value) {\n      _resolve2 && _resolve2(value);\n    },\n    reject: function reject(reason) {\n      _reject2 && _reject2(reason);\n    },\n    cancel: function cancel() {\n      _resolve2 = null;\n      _reject2 = null;\n    }\n  };\n}\n\nexport { createImperativePromise };","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"iCAW2C,U,EAA0C;AACnF,MAAI,SAAO,GAA8B,IAAzC;AACA,MAAI,QAAM,GAA0B,IAApC;AAEA,MAAM,cAAc,GAAG,IAAI,OAAJ,CAAe,UAAC,QAAD,EAAW,OAAX,EAAkB;AACtD,IAAA,SAAO,GAAG,QAAV;AACA,IAAA,QAAM,GAAG,OAAT;AACD,GAHsB,CAAvB;AAKA,EAAA,UAAU,IAAI,UAAU,CAAC,IAAX,CACZ,UAAA,GAAA,EAAG;AACD,IAAA,SAAO,IAAI,SAAO,CAAC,GAAD,CAAlB;AACD,GAHW,EAIZ,UAAA,KAAA,EAAK;AACH,IAAA,QAAM,IAAI,QAAM,CAAC,KAAD,CAAhB;AACD,GANW,CAAd;AASA,SAAO;AACL,IAAA,OAAO,EAAE,cADJ;AAEL,IAAA,OAAO,EAAE,iBAAC,KAAD,EAA0B;AACjC,MAAA,SAAO,IAAI,SAAO,CAAC,KAAD,CAAlB;AACD,KAJI;AAKL,IAAA,MAAM,EAAE,gBAAC,MAAD,EAAa;AACnB,MAAA,QAAM,IAAI,QAAM,CAAC,MAAD,CAAhB;AACD,KAPI;AAQL,IAAA,MAAM,EAAE,kBAAA;AACN,MAAA,SAAO,GAAG,IAAV;AACA,MAAA,QAAM,GAAG,IAAT;AACD;AAXI,GAAP;AAaD","sourcesContent":["export type ResolveCallback<T> = (value: T | PromiseLike<T>) => void\nexport type RejectCallback = (reason?: any) => void\nexport type CancelCallback = () => void\n\nexport type ImperativePromise<T> = {\n  promise: Promise<T>\n  resolve: ResolveCallback<T>\n  reject: RejectCallback\n  cancel: CancelCallback\n}\n\nexport function createImperativePromise<T>(promiseArg?: Promise<T> | null | undefined): ImperativePromise<T> {\n  let resolve: ResolveCallback<T> | null = null\n  let reject: RejectCallback | null = null\n\n  const wrappedPromise = new Promise<T>((_resolve, _reject) => {\n    resolve = _resolve\n    reject = _reject\n  })\n\n  promiseArg && promiseArg.then(\n    val => {\n      resolve && resolve(val)\n    },\n    error => {\n      reject && reject(error)\n    }\n  )\n\n  return {\n    promise: wrappedPromise,\n    resolve: (value: T | PromiseLike<T>) => {\n      resolve && resolve(value)\n    },\n    reject: (reason?: any) => {\n      reject && reject(reason)\n    },\n    cancel: () => {\n      resolve = null\n      reject = null\n    }\n  }\n}\n\n\n"]},"metadata":{},"sourceType":"module"}